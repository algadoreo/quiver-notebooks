{
  "title": "Arduino code: `comm_chain_with_boxcar.ino`",
  "cells": [
    {
      "type": "markdown",
      "data": "# Motivation\n\nWe want to set up a chain of Arduino DUE units to read temperature sensors and pass their values back to a main computer.\n\nSince there are twelve 12-bit analog inputs on each Arduino DUE, a set of ~100 temperature sensors (thermistors) will require ~10 devices in the chain."
    },
    {
      "type": "markdown",
      "data": "# Setup\n\nThe basic setup has one Arduino device connected to the main computer via a serial connection, while the Arduino devices themselves communicate via two-wire I$^2$C connections. Each device has the exact same code, with a boolean `isDev0` flag defaulted to `false`. Upon receipt of a serial command, this flag flips to `true` – indicating the device is Device 0 – and a message chain is initiated.\n\nThe Arduino DUE, unlike other models, has two separate I$^2$C ports, allowing two independent channels of communication. Because only one of these ports (`SDA` and `SCL`; pins 20 and 21) come equipped with pull-up resistors, that will be designated as the WRITE port. The other port (`SDA1` and `SCL1`; pins 70 and 71) will be designated as the READ port.\n\n(Should pull-up resistors be desired for the READ port, connect the two lines in parallel to the Arduino’s 3.3 V output through 4.7 kΩ resistors.)\n\nOnce the message chain has completed its circuit – i.e., readings have been taken from every device and returned to Device 0 – it is sent back to the main computer by Device 0 via serial, and the `isDev0` flag reverts to `false`. The cycle begins anew."
    },
    {
      "type": "markdown",
      "data": "# I$^2$C communication\n\nThe `Wire` library contains a suite of functions useful for two-wire I$^2$C communication. See https://www.arduino.cc/en/Reference/Wire.\n\nThe library is installed (on a Mac) in `~/Library/Arduino15/packages/arduino/hardware/sam/<version>/libraries/`. For Arduino boards other than a DUE, `sam` is replaced by the board type.\n\n### Usage\n\n**N.B.:** The `Wire` library functions mostly assume a master–slave setup, despite this not being a requirement for I$^2$C. Though somewhat restricting, the two separate I$^2$C ports can be set independently as master and slave. For our purposes, we initiate the WRITE port (pins 20 and 21) as master, and the READ port (pins 70 and 71) as a slave on **address 9**. (Because each master will ever only see one slave, all slaves can be set to the same address.)\n\nThe WRITE port (`SDA` and `SCL`; pins 20 and 21) are called using `Wire`, e.g., `Wire.begin()`.\nThe READ port (`SDA1` and `SCL1`; pins 70 and 71) are called using `Wire1`, e.g., `Wire1.begin(9)` – the `9` designating the slave address.\n\n### Clock speed\n\nThe Atmel SAM3X8E chip on the Arduino DUE is capable of communicating via I$^2$C at a clock speed up to 400 kHz (default is 100 kHz). In the `Wire` library, the clock speed is set by the function `Wire.setClock(400000);` (and the equivalent with `Wire1`).\n\nThe default speed was found to noticeably slow down the 500 Hz sampling."
    },
    {
      "type": "markdown",
      "data": "# Noise filtering\n\nDuring testing, the 12-bit analog input was found to have an error of 3–4 counts (out of 4096), reducing the effective number of bits from 12 to 10 (i.e., the two lowest bits fluctuate too much to be useful). We could either lowpass-filter this with an analog or a digital filter. The latter was preferred because hardware calibration would add an additional source of error. However, the software solution requires there be sufficient CPU cycles.\n\n### Moving average filter\n\nThe easiest digital lowpass filter to implement is probably the moving average (boxcar) filter. A length-$L$ boxcar filter has an impulse response given by\n\\begin{align}\nh[n] = \\sum_{i=0}^{L-1} b_i \\cdot \\delta[n-i], \\quad b_i \\equiv \\frac{1}{L}\n\\end{align} and a frequency response of\n\\begin{align}\nH(\\omega) = \\sum_{m=-\\infty}^{+\\infty} h[m] \\, e^{-i\\omega m} = \\frac{1}{L} \\cdot \\frac{1 - e^{-i\\omega L}}{1 - e^{-i\\omega}}.\n\\end{align} It is therefore a comb filter with notches evenly spaced at frequencies $f = n/L$, where $n$ is any non-zero integer.\n\n### Application\n\nSince we don’t expect temperatures to change drastically within a second, we only want a sample once every, say, 200 ms (5 Hz). If we simply sampled at this rate, our standard variance would be 3–4 counts as before. We can do much better by applying the boxcar filter: By sampling 100 times faster (every 2 ms; 500 Hz), we’d have 100 samples every 200 ms; the average of those 100 samples has 10 times lower noise than before – the standard deviation of means decrease as $\\sim 1/\\sqrt{L}$. The limit to which we can do this is determined entirely by the CPU cycles available.\n\nWithout invoking (hardware) interrupts, the Arduino DUE was found to be capable of reliably sampling at 500 Hz (2000 µs) using the following implementation.\n\nWe initiate a (circular) buffer of sufficient length and two pointers to demarcate a boxcar of length $L$. The sum of the values within the boxcar is stored in a separate array (one value for each channel). We store the sum rather than the average because division is expensive, and known constant factors can always be handled offline (basically a unit conversion). For maximum efficiency, the sum is updated by subtracting the value at the end of the boxcar (i.e., the element at `sub_ptr`) and adding the new value at the front of the boxcar (i.e., the element at `add_ptr`).\n\n**The value in the sum array is the value to be read out.** The rate at which this happens depends on the desired filter and is handled by the main computer. Using the values below and a constant voltage source (a DC power supply), the standard deviation of the output values was found to be ~0.2 counts (out of 4096)."
    },
    {
      "type": "markdown",
      "data": "# To do\n\nThere a still a few things to clean up before the system can be deployed, but they aren’t too difficult – I just ran out of time.\n\n## Serial input\n\nWe envision the main computer to be the one requesting readouts via USB (serial port) every 200 ms (5 Hz).\n\n**Current setup:** Device 0 sends initiates the data chain every 200 ms\n**To do:** the `isDev0` flag should be triggered by the request from serial; default value = `false`; every time data is returned to the main computer, `isDev0` should revert to `false`\n\n## Serial output\n\nThere is a buffer of 128 bytes. Sending all 12 channels as binary should work (at least for two devices), but definitely not ASCII.\n\nThe buffer size is defined in `~/Library/Arduino15/packages/arduino/hardware/sam/<version>/cores/arduino/Ringbuffer.h`, on the line `#define SERIAL_BUFFER_SIZE 128`. The buffer size need not be changed if the communications was handled smartly. Keep in mind that there is limited onboard memory on the Arduino. Think about how to separate the message packets (if necessary)."
    },
    {
      "type": "markdown",
      "data": "# Code\n\nBelow is the code in its entirety."
    },
    {
      "type": "code",
      "language": "c_cpp",
      "data": "#include <Wire.h>\n\n// constants\nconst int dt = 2000; // sampling rate [microseconds]\nconst int Dt = 200;  // readout rate [milliseconds]\nconst int N = 250;   // buffer length\nconst int L = 200;   // boxcar length\nconst byte Nch = 12;  // number of channels per device\nconst byte Ndev = 10; // number of devices in chain\n\nunsigned long sum[Nch] = {0};    // sums from current board\nunsigned long rcvsum[Ndev][Nch] = {0}; // sums received from another board\n\nbool isDev0 = true; // is (not) device connected via serial\n\nvoid setup() {\n  unsigned short add_ptr = 0;\n  unsigned short sub_ptr = add_ptr + N - L;\n  unsigned long old_micros = 0, new_micros = 0;\n  unsigned long old_millis = 0, new_millis = 0;\n  unsigned short buffdata[N][Nch] = {0};\n  unsigned short old_voltage = 0, new_voltage = 0;\n  \n  Serial.begin(250000);\n  analogReadResolution(12);\n  analogWriteResolution(12);\n  for (byte i=54; i<66; i++) {\n    pinMode(i, INPUT);\n  }\n\n  // Start the first I2C bus as master\n  Wire.begin();\n  Wire.setClock(400000);\n  \n  // begin I2C bus on address 9\n  Wire1.begin(9);\n  Wire1.setClock(400000);\n  Wire1.onReceive(receiveEvent);\n\n  while (true) {\n    // take samples every dt microseconds\n    new_micros = micros();\n    if ((new_micros - old_micros) >= dt) {\n      for (byte j=0; j<Nch; j++) {\n        new_voltage = analogRead(54+j);\n        old_voltage = buffdata[sub_ptr][j];\n        buffdata[add_ptr][j] = new_voltage;\n        sum[j] += new_voltage - old_voltage;\n      }\n\n      old_micros = new_micros;\n      (add_ptr==N-1) ? add_ptr = 0 : add_ptr++;\n      (sub_ptr==N-1) ? sub_ptr = 0 : sub_ptr++;\n    }\n\n    // if Device 0, send out sums every Dt MILLIseconds\n    // TO DO: message chain initialized by serial request; once\n    // once that is set up, this shouldn't be timer-based\n    if (isDev0) {\n      new_millis = millis();\n      if ((new_millis - old_millis) >= Dt) {\n        Wire.beginTransmission(9);\n        Wire.write(1);\n        Wire.write(1);\n        for (byte i=0; i<Nch; i++) {\n          for (byte j=0; j<3; j++) {\n            Wire.write(sum[i] >> (8*j));\n          }\n        }\n        Wire.endTransmission();\n        old_millis = new_millis;\n      }\n    }\n  }\n}\n\nvoid receiveEvent(int Nbytes) {\n  unsigned short packetsTotal = 0;\n  unsigned short packetNumber = 0;\n  unsigned int x = 0;\n  \n  while (Wire1.available()) {\n    // first two bytes are meta-data\n    packetsTotal = Wire1.read();\n    packetNumber = Wire1.read();\n\n    // fill the buffer with the received packets\n    for (byte i=0; i<Nch; i++) {\n      x = 0;\n      for (byte j=0; j<3; j++) {\n        x = (Wire1.read() << (8*j)) | x;\n      }\n      rcvsum[packetNumber-1][i] = x;\n    }\n  }\n\n  // if Device 0, output to serial once all packets received;\n  // else pass along message on `Wire`\n  if (isDev0) {\n    if (packetNumber == packetsTotal) {\n      for (byte k=0; k<packetsTotal; k++) {\n        Serial.print(k+1);\n        // TO DO: fix serial output; currently limited by buffer size\n//        for (byte i=0; i<Nch; i++) {\n        for (byte i=0; i<8; i++) {\n          Serial.print(\" \");\n          Serial.print(rcvsum[k][i]);\n        }\n        Serial.println();\n      }\n    }\n  } else {\n    // send the values received from other devices\n    // have to break into one packet per device due to 32-byte limit\n    for (byte k=0; k<packetsTotal; k++) {\n      Wire.beginTransmission(9);\n      Wire.write(packetsTotal+1);\n      Wire.write(k+1);\n      for (byte i=0; i<Nch; i++) {\n        for (byte j=0; j<3; j++) {\n          Wire.write(rcvsum[k][i] >> (8*j));\n        }\n      }\n      Wire.endTransmission(); \n    }\n\n    // send the values on current device\n    Wire.beginTransmission(9);\n    Wire.write(packetsTotal+1);\n    Wire.write(packetsTotal+1);\n    for (byte i=0; i<Nch; i++) {\n      for (byte j=0; j<3; j++) {\n        Wire.write(sum[i] >> (8*j));\n      }\n    }\n    Wire.endTransmission();\n  }\n}\n\nvoid loop() {\n  // empty because the loop is in setup()\n}\n"
    },
    {
      "type": "markdown",
      "data": "# Demonstration\n\nTo test our setup, we have two Arduino DUE devices in the chain. A thermistor is connected to Device 1 via a 1-meter long wire on each end. While no detectors are connected to Device 0 for now, it requests a readout every 200 ms (5 Hz) and sends the data back to the main computer.\n\nOur circuit was set up as a voltage divider, with the thermistor as the first resistor; $V_\\text{out} \\propto 1/R_1$.\n\nThe thermistor used is Digi-key #490-7170-ND (Murata Electronics NXR-T-15-XM-202-E-A-1-B-040). For specs, see https://www.digikey.ca/product-detail/en/murata-electronics-north-america/NXRT15XM202EA1B040/490-7170-ND/3900401. The resistance is 2 kΩ at 25°C and decreases exponentially with temperature, $R(T) \\propto \\exp(1/T)$. **N.B.:** one consequence of this scaling is that the sensitivity (dynamic range) is reduced at high temperatures, i.e., a large change in $T$ will register only a little change in $R$.\n\n### Cases\n\nWe produced 2-minute (600-sample) timestreams for each of the four cases:\n\n1. Untwisted wire, thermistor exposed\n2. Untwisted wire, thermistor in a box\n3. Twisted wire, thermistor exposed\n4. Twisted wire, thermistor in a box\n\nThe timestreams are shown in Figure 1.\n\nWhen the thermistor is exposed (cases 1 and 3), the readings are subject to shifting air currents in the laboratory (result of AC, people walking by, etc.) and the associated temperature changes. Placing the thermistor in a box (cases 2 and 4) stabilizes the temperature quite noticeably; the temperature inside the unventilated box was also likely higher.\n\nTwisting the two 1 m wires together (cases 3 and 4) appears to increase the resistance in that segment, but this hasn’t been sufficiently tested."
    },
    {
      "type": "text",
      "data": "<div><img src=\"quiver-image-url/E1CBA21039035775CCF44AAD81085DA1.png\" alt=\"cases.png\" width=\"1152\" height=\"648\"><br></div><div><b>Figure 1:</b> The four timestreams. As expected, the exposed thermistor (cases 1 and 3) show much greater variability in its readings due to shifting air currents in the laboratory. Twisting the wire (cases 3 and 4) seems to reduce the voltage readout (increased resistance), but this has not been sufficiently tested.</div>"
    }
  ]
}